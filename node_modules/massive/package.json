{
  "_args": [
    [
      {
        "raw": "massive@^4.7.0",
        "scope": null,
        "escapedName": "massive",
        "name": "massive",
        "rawSpec": "^4.7.0",
        "spec": ">=4.7.0 <5.0.0",
        "type": "range"
      },
      "/Users/danieljensen/Desktop/MeetMan3"
    ]
  ],
  "_from": "massive@>=4.7.0 <5.0.0",
  "_id": "massive@4.7.2",
  "_inCache": true,
  "_location": "/massive",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/massive_4.7.2_1523969524686_0.5374822283464396"
  },
  "_npmUser": {
    "name": "dmfay",
    "email": "dian.m.fay@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "massive@^4.7.0",
    "scope": null,
    "escapedName": "massive",
    "name": "massive",
    "rawSpec": "^4.7.0",
    "spec": ">=4.7.0 <5.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/massive/-/massive-4.7.2.tgz",
  "_shasum": "e7cb4f00a36ffe39e7e2d48a551f7a0156dd4747",
  "_shrinkwrap": null,
  "_spec": "massive@^4.7.0",
  "_where": "/Users/danieljensen/Desktop/MeetMan3",
  "author": {
    "name": "Dian Fay",
    "email": "dian.m.fay@gmail.com"
  },
  "bin": {
    "massive": "bin/massive.js"
  },
  "bugs": {
    "url": "https://github.com/dmfay/massive-js/issues"
  },
  "contributors": [
    {
      "name": "Karl Seguin",
      "email": "karl@openmymind.net"
    },
    {
      "name": "John Atten",
      "email": "xivsolutions@gmail.com"
    },
    {
      "name": "Rob Conery",
      "email": "robconery@gmail.com"
    }
  ],
  "dependencies": {
    "commander": "~2.15.0",
    "glob": "~7.1.1",
    "lodash": "~4.17.4",
    "pg-promise": "~8.2.0",
    "pg-query-stream": "~1.1.1"
  },
  "description": "A small query tool for Postgres that embraces json and makes life simpler",
  "devDependencies": {
    "chai": "~4.1.0",
    "chai-as-promised": "~7.1.1",
    "co-mocha": "~1.2.0",
    "coveralls": "~3.0.0",
    "eslint": "~4.19.0",
    "jsdoc": "^3.5.4",
    "mocha": "~5.1.0",
    "nyc": "~11.6.0"
  },
  "directories": {
    "bin": "bin",
    "lib": "lib",
    "test": "test"
  },
  "dist": {
    "integrity": "sha512-mF7eQuen0PLODV9wgzvcPpttJjphdKGWUjxWcVH0AbVfy0+4t6KprVLkdNW7e8za3r7dM9hAPgH65eULtTxfBQ==",
    "shasum": "e7cb4f00a36ffe39e7e2d48a551f7a0156dd4747",
    "tarball": "https://registry.npmjs.org/massive/-/massive-4.7.2.tgz",
    "fileCount": 43,
    "unpackedSize": 158297,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa1e32CRA9TVsSAnZWagAA2VoP/jbYVRUMaES1u2Gpz8d5\nAHYd+NITLma007zlrzqgGeechQcgMtQyPfK5tB5gGUB4LDd9KALiXSxeeIs/\nZSD6WVFNzV1PN577cQHcv6vmtzd8omaZCI0Ij8IQhL4BhhjAKWxx0CP9BY7z\n8J2NjTAsb1bumRMP61cAnQyE/JYl9gfiSYjXLGzhthLlpg9qqvZE/bKp5P0o\njOpm0vWvqeWDL3IGJGxFjRK2cgWSTC/Eo5KjMkha7iS5qGeso59CPRVyLE+0\nA6gRXsKPxji3VUBQ79DOfNRn52rUOb9IRIXQBP0u6a5LqXZyaPdJhBCXLKoR\ne14VRIL5ortnAip0qJX7hXX6vblbo485A9w0sID4f0uwbLpDfGegYLDPJ8hs\ngjsQpQk4H26rYloFb/BILrefiIwA1Da4UasjA6nTwpVzwX1dSjeITbVVOUsz\nHOGgdQyUkeeixqUhHRdGlrVtXqq6hfZH/qnjPEDuQke3WCV5B3DaR7ldvL4V\nFDo+Gy9Frd5iqaqkS4xvgZx3K7G8fyokMAU3IDRuBNzcTqABQb1BMvF2u8CJ\nwqiRDkUxZtU15Adw9/bp4mSU3nMcnEicG2rXlrkpZYfxdNnV0ighrgPlTQ6g\nR/OTdkgvovR8qB/wDYfIuZ3jyiTOzrhx4sni3+Tm+WX4YaBdC2kLq4So37Lv\n8u6r\r\n=jJaj\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 6.0.0"
  },
  "files": [
    "bin",
    "*.md",
    "docs/*.md",
    "*.js",
    "lib"
  ],
  "gitHead": "96898b3356a00224018dd5a884b434dc02987ac6",
  "homepage": "https://dmfay.github.io/massive-js/",
  "keywords": [
    "postgres",
    "pg",
    "postgresql",
    "sql",
    "database",
    "datamapper",
    "data-mapper",
    "promise",
    "promises"
  ],
  "license": "BSD-3-Clause",
  "main": "index.js",
  "maintainers": [
    {
      "name": "dmfay",
      "email": "dian.m.fay@gmail.com"
    },
    {
      "name": "robconery",
      "email": "robconery@gmail.com"
    }
  ],
  "name": "massive",
  "optionalDependencies": {},
  "readme": "# Massive.js: A Postgres-centric Data Access Tool\n\n[![node](https://img.shields.io/node/v/massive.svg)](https://npmjs.org/package/massive)\n[![Build Status](https://travis-ci.org/dmfay/massive-js.svg?branch=master)](https://travis-ci.org/dmfay/massive-js)\n[![Coverage Status](https://coveralls.io/repos/github/dmfay/massive-js/badge.svg)](https://coveralls.io/github/dmfay/massive-js)\n[![Greenkeeper badge](https://badges.greenkeeper.io/dmfay/massive-js.svg)](https://greenkeeper.io/)\n[![npm](https://img.shields.io/npm/dw/massive.svg)](https://npmjs.org/package/massive)\n\nMassive.js is a data mapper for Node.js that goes all in on PostgreSQL and fully embraces the power and flexibility of the SQL language and relational metaphors. Providing minimal abstractions for the interfaces and tools you already use, its goal is to do just enough to make working with your data as easy and intuitive as possible, then get out of your way.\n\nMassive is _not_ an object-relational mapper (ORM)! It doesn't use models, it doesn't track state, and it doesn't limit you to a single entity-based metaphor for accessing and persisting data. Massive connects to your database and introspects its schemas to build an API for the data model you already have: your tables, views, functions, and easily-modified SQL scripts.\n\nHere are some of the high points:\n\n* **Dynamic query generation**: Massive's versatile query builder supports a wide variety of operators, all generated from a simple criteria object.\n* **Low overhead**: An API built from your schema means no model classes to maintain, super-simple bulk operations, and writing directly to tables without any need to create or load entity instances beforehand.\n* **Document storage**: PostgreSQL's JSONB storage type makes it possible to blend relational and document strategies. Massive offers a robust API to simplify working with documents: objects in, objects out, with document metadata managed for you.\n* **Relational awareness**: Massive does not traverse relationships or build model graphs, but [deep inserts](https://dmfay.github.io/massive-js/persistence.html#deep-insert) can create related entities and junctions transactionally, and the [`decompose` option](https://dmfay.github.io/massive-js/options.html#decomposition-schemas) allows you to map the results of complex views and scripts to nested object trees.\n* **Postgres everything**: Commitment to a single RDBMS lets us use it to its full potential. Massive supports array fields and operations, regular expression matching, foreign tables, materialized views, and more features found in PostgreSQL but not in other databases.\n\n## Full Documentation\n\n[Full documentation including API docs is available on GitHub Pages.](https://dmfay.github.io/massive-js/)\n\n## Contributing\n\n[See CONTRIBUTING.md](https://github.com/dmfay/massive-js/blob/master/CONTRIBUTING.md).\n\n## Table of Contents\n\n<!-- vim-markdown-toc GFM -->\n* [Installation](#installation)\n* [Connecting to a Database](#connecting-to-a-database)\n* [Usage](#usage)\n  * [Criteria Objects](#criteria-objects)\n  * [Query Options](#query-options)\n  * [A Brief Example](#a-brief-example)\n    * [Persistence](#persistence)\n    * [Retrieval](#retrieval)\n    * [Deleting](#deleting)\n    * [Functions and Scripts](#functions-and-scripts)\n    * [Views](#views)\n    * [Arbitrary Queries](#arbitrary-queries)\n    * [Documents](#documents)\n  * [Accessing the Driver](#accessing-the-driver)\n* [REPL](#repl)\n* [Older Versions](#older-versions)\n\n<!-- vim-markdown-toc -->\n\n## Installation\n\n```\nnpm i massive --save\n```\n\n**Starting with version 3.0.0, Massive requires ES6 support and uses Promises exclusively. If you need a callback-based API or are using a pre-6.x release of Node.js, install massive@2 or download version 2.x from [the Releases page](https://github.com/dmfay/massive-js/releases).**\n\nExamples are presented using the standard `then()` construction for compatibility, but use of ES2017 `async` and `await` or a flow control library such as [co](https://github.com/tj/co) to manage promises is highly recommended.\n\n## Connecting to a Database\n\nOnce installed, `require` the library and connect to your database with a parameter object or connection string:\n\n```javascript\nconst massive = require('massive');\n\nmassive({\n  host: '127.0.0.1',\n  port: 5432,\n  database: 'appdb',\n  user: 'appuser',\n  password: 'apppwd'\n}).then(db => {...});\n```\n\nWhen you instantiate Massive, it introspects your database to discover the objects you use to store and retrieve data. These objects become an API for your database on the connected Massive instance itself. The following classes of database object are supported:\n\n* All tables having primary key constraints\n* Foreign tables\n* Views, including materialized views\n* Functions\n\nMassive understands database schemas and treats any schema other than `public` (or your default configured in Postgres) as a namespace. Objects in the `public` schema are attached directly to the connected instance, while those in other schemas will be attached in a namespace on the instance.\n\nMost objects can coexist if they wind up in the same namespace. For example, you might have a table named `companies` and a schema named `companies` which contains more tables. In this scenario, `db.companies` will be a table and _also_ a schema, so you might query `db.companies.find(...)` and `db.companies.audit.find(...)` as you need to.\n\nThere are a few specific cases in which collisions will result in an error:\n\n* When a script file or database function would override a function belonging to a loaded table or view (or vice versa): for example, `db.mytable` already has a `find()` function, so a script file named `mytable/find.sql` cannot be loaded.\n* When a script file has the same path as a database function.\n\nThe introspection process is fast, but not instantaneous, and you don't want to be doing it every time you run another query. Massive is designed to be initialized once, with the instance retained and used throughout the rest of your application.  In Express, you can store the connected instance with `app.set` in your entry point and retrieve it with `req.app.get` in your routes; or with koa, using `app.context`. If no such mechanism is available, you can take advantage of Node's module caching to require the object as necessary.\n\nIf you ever need to run the introspection again, use `db.reload()` to get a promise for an up-to-date instance.\n\n## Usage\n\nConsult the [documentation](https://dmfay.github.io/massive-js/) for full usage instructions.\n\n### Criteria Objects\n\nMany functions use criteria objects to build a query WHERE clause. A criteria object is a JavaScript map matching database fields to values. Unless otherwise specified in the field name, the predicate operation is assumed to be equality. Massive's query builder is extremely flexible and accommodates both standard and Postgres-specific predicates, including JSON object traversal and array and regexp operations.\n\n```javascript\n{\n  'field': 'value',               // equality\n  'field <>': 'value',            // inequality\n  'field': [1, 2, 3],             // IN (x, y, z) tests\n  'field >': 1,                   // greater than\n  'field <=': 1,                  // less than or equal\n  'field BETWEEN': [1, 100],      // BETWEEN\n  'field LIKE': 'val%',           // LIKE\n  'field NOT ILIKE': 'Val%',      // NOT LIKE (case-insensitive)\n  'field ~': 'val[ue]+',          // regexp match\n  'field !~*': 'Val[ue]+',        // no regexp match (case-insensitive)\n  'field @>': ['value', 'Value'], // array contains\n  'field.arr[1].item': 'value'    // JSON traversal\n}\n```\n\nThere are many more; see [the full documentation](https://dmfay.github.io/massive-js/criteria.html) for the complete list.\n\n### Query Options\n\nSome functions, particularly the query functions (`find`, `findOne`, `findDoc`, `search`, and `searchDoc`) allow usage of an options object as the second argument. Like the criteria object, this is an ordinary JavaScript map; however, the field names are fixed. Any field may be omitted if not needed. The options object may be omitted entirely if not needed.\n\n```javascript\n{\n  build: true,                    // return query text and parameters without executing anything\n  document: true,                 // treat table as a document store (see 'Documents')\n  fields: ['name', 'created_at']  // retrieve only the specified fields (can be used with exprs)\n  exprs: {                        // retrieve the specified expressions (can be used with fields)\n    lowername: 'lower(name)'\n  }\n  order: [{                       // creates an ORDER BY clause to enforce sorting\n    field: 'settings.role',       // JSON fields use . and [] notation\n    direction: 'desc',            // set the sort direction with 'desc' or 'asc' (optional)\n    type: 'int'                   // enforce a cast type (optional)\n  }, {\n    field: 'name'                 // order elements are applied in order\n  }],\n  orderBody: true,                // order applies to document body fields instead of table columns\n  offset: 20,                     // adds an OFFSET to skip the first n rows\n  limit: 10,                      // adds a LIMIT to restrict the number of rows returned\n  single: true,                   // return the first result row as an object instead of all rows\n  stream: true,                   // return results as a readable stream (see below)\n  only: true                      // ignore tables inheriting from the target table\n}\n```\n\nComplete documentation for query options is available [here](https://dmfay.github.io/massive-js/options.html).\n\n### A Brief Example\n\nLet's say we have a database for a software testing application. This database contains a `tests` table and an `issues` table, where one test may have many issues. In a separate `auth` schema, it contains a `users` table referenced by the others to represent a user running a test and discovering issues. There is a `test_stats` view which calculates statistics on aggregate issue information for individual tests, and a `user_tests` view which returns all users with their associated tests; and there is a `copy_tests` function which clones a test for reuse.\n\nOur testing application can leverage the API Massive builds for almost everything it needs to do, but there is one feature that we haven't been able to integrate as a database function yet: the ability to, in one call, clear a test's issues and update its status to signify that it has been restarted. Eventually, we'll get there, but for now it's a SQL script in our application's `/db` directory, `resetTest.sql`.\n\n#### Persistence\n\nAfter we initialize and connect Massive, all these entities are available on the instance. First, we need to create a user:\n\n```javascript\ndb.auth.users.insert({\n  username: 'alice',\n  password: 'supersecure'\n}).then(alice => {...});\n```\n\n`alice` is a JavaScript object containing the username and password we specified. But our `users` table has more columns than that: first and foremost, there's a primary key, an `id` column, which uniquely identifies this user record. A user also has a `role`, a `created_at` timestamp defaulting to the current date on insert, and an `updated_at` timestamp to track when the record was last modified. So in addition to the fields we provided, `alice` has an `id`, a `role`, a `created_at`, and an `updated_at`. Since we didn't specify values for `role` or `updated_at`, these are `null`.\n\nWhen Alice resets her password, we issue an `update`:\n\n```javascript\ndb.auth.users.update({\n  id: 1,\n  password: 'evenmoresecure'\n}).then(alice => {...});\n```\n\nThe `update` will search by the primary key in the object and modify only those fields we include. Since Alice's username isn't changing, we don't need to include that in the object we're passing. However, it won't hurt anything if we do, so we could have simply modified the original `alice` object and passed that in instead.\n\n`alice` still doesn't have a role, however, and we may have added more users without roles as well. Let's perform a bulk update to ensure that users have a minimal level of access:\n\n```javascript\ndb.auth.users.update({\n  'role is': null\n}, {\n  role: 'tester'\n}).then(users => {...});\n```\n\nNow that `alice` exists in the system and has the correct role, she can start a test. When working with tests, however, we'd rather be a little more efficient and not have separate `insert` and `update` paths. We can create or retrieve a `test` object and perform an upsert -- creating it if it doesn't exist, or modifying it if it does -- using the `save` function:\n\n```javascript\ndb.tests.save({\n  name: 'application homepage',\n  url: 'http://www.example.com',\n  user_id: alice.id\n}).then(test => {...});\n```\n\nHad we already had a test and specified its id, we'd have updated that record. Since we didn't, we have a new test instead.\n\n#### Retrieval\n\nSome time later, we want to retrieve that test. But we don't have the object returned from `save`, so we need to go back to the database with the primary key:\n\n```javascript\ndb.tests.findOne(1).then(test => {...});\n```\n\nIn the mean time, Alice has been busy and discovered several problems which are now stored in the `issues` table. We can see how many she's found with `count`:\n\n```javascript\ndb.issues.count({test_id: 1}).then(total => {...});\n```\n\nSince Postgres' `count` returns a 64-bit integer and JavaScript only handles up to 53 bits, `total` will actually be a string. But thanks to JavaScript's weak typing this generally doesn't matter. Next, let's actually pull out the issue data:\n\n```javascript\ndb.issues.find({\n  test_id: 1\n}, {\n  order: [{field: 'created_at', direction: 'desc'}]\n}).then(issues => {...});\n```\n\nThe second object we passed defines query options; here, we're sorting the issues most recent first. There are many other options which affect query shape and results processing, and the options object can be used with many of the retrieval and persistence functions. The output of our `find` call is the `issues` array, which contains all records in that table matching the criteria we passed to `find`.\n\nThere are other retrieval functions: `where` allows us to write more complex `WHERE` clauses than those `find` can generate based on the criteria object, and `search` performs a full-text search against multiple fields in a table. [The documentation](https://dmfay.github.io/massive-js/queries.html) has more information on these.\n\n#### Deleting\n\nAfter review, it turns out that one of the issues Alice discovered was actually the application working as designed, so she needs to delete the isssue. We can do that with `destroy`:\n\n```javascript\ndb.issues.destroy(3).then(issues => {...});\n```\n\nThe issue has been deleted, and the record returned -- in an array this time, since `destroy` can be used with a criteria object just like we used `find` to retrieve multiple issues.\n\n#### Functions and Scripts\n\nBob wants to start testing the homepage, but doesn't want to go through the entire setup process. Fortunately, there's a `copy_test` function which will let him build on Alice's work, if he passes in the test id and his userid to assign the clone to himself:\n\n```javascript\ndb.copy_test(test.id, bob.id)\n  .then(test => {...})\n```\n\nThere's an important note here: this example assumes that Massive has been initialized with `enhancedFunctions`. With this flag enabled, Massive detects the shape of database functions' output, and will return a single record object -- or even a scalar value -- as appropriate. Since `copy_test` only makes one copy, it does return the record object. Without `enhancedFunctions`, this invocation would return an array containing the single record.\n\nShortly after Bob starts testing, the application is redeployed underneath him, invalidating the results he's gathered so far. He could delete issues with `destroy` either individually or in bulk, but it's faster to use the `resetTest` script. This works exactly as if it were a database function, except that `enhancedFunctions` does not perform any result type introspection, so the results will always be an array:\n\n```javascript\ndb.resetTest(test.id).then(tests => {...});\n```\n\n#### Views\n\nAfter Alice has finished testing, she wants to see how her results compare to Bob's. We can query the `test_stats` view just like we did the `issues` and `tests` tables, with exactly the same API functions -- the only difference is that, since it's a view, we can't persist data to it.\n\n```javascript\ndb.test_stats.find({\n  url: 'http://www.example.com'\n}).then(stats => {...})\n```\n\n`stats` is an array of records from the view which match the criteria object.\n\nMany views (or scripts!) combine related results from multiple tables. The `user_tests` view is one such. Rows might look like this:\n\n| user_id | username | test_id | name   |\n|---------|----------|---------|--------|\n|       1 | alice    |       1 | first  |\n|       1 | alice    |       2 | second |\n|       2 | bob      |       3 | third  |\n\nDatabases are limited to working with this kind of information in terms of flat tables and relationships, and when you have a situation where Alice has multiple tests, that means Alice appears twice in the output. In JavaScript, however, we're more accustomed to working with object graphs where, instead of parent entities (users) being duplicated, the descendant entities (tests) are nested. Something like this:\n\n```javascript\n[{\n  id: 1,\n  username: 'alice',\n  tests: [{\n    id: 1,\n    name: 'first'\n  }, {\n    id: 2,\n    name: 'second'\n  }]\n}, {\n  id: 2,\n  username: 'bob',\n  tests: [{\n    id: 3,\n    name: 'third'\n  }]\n}]\n```\n\nMassive can transform any view or script result into an object graph with the `decompose` option. The value of `decompose` is a schema which represents the desired output format. To generate the structure above:\n\n```javascript\ndb.user_tests.find({}, {\n  decompose: {\n    pk: 'user_id',\n    columns: {\n      user_id: 'id',\n      username: 'username'\n    },\n    tests: {\n      pk: 'test_id',\n      columns: {\n        test_id: 'id',\n        name: 'name'\n      },\n      array: true\n    }\n  }\n}).then(...)\n```\n\nSee the [options docs](https://dmfay.github.io/massive-js/options.html) for a complete guide to the schema object.\n\n#### Arbitrary Queries\n\nAlice's and Bob's passwords are both stored as plain text, because we were originally more focused on getting up and running than we were on doing things right. Now it's time to rectify this, especially since we've started adding new users through a system that hashes and salts passwords with a `hash` database function and our application login expects passwords to be hashed. So we need to ensure that all our users have hashed passwords, which we can do with an ad-hoc query in the REPL:\n\n```javascript\ndb.query(\n  'update users set password = hash(password) where id < $1 returning *',\n  [3]\n).then(users => {...});\n```\n\nThe value returned is an array of rows, assuming the query returns anything. `query` is most useful for one-offs like this, or for testing when you don't want to have to reload the database API to get changes to a script file. Once the query is ready for regular use, though, it's best to put it in a file in your scripts directory so you have all your scripts in a central location.\n\n#### Documents\n\nThe `tests` table represents a fairly limited picture of what exactly Alice and Bob are doing. An individual test may have a lot more data associated with it, and this data could be wildly different depending on what precisely is being evaluated, so simply adding more columns to `tests` isn't really an ideal solution. Postgres' JSONB functionality allows for a more free-form approach than relational databases otherwise support. Working with JSONB fields is certainly possible with the suite of standard table functions, but Massive also allows the dynamic creation and usage of dedicated document tables with a separate set of functions based on the relational data persistence and retrieval functionality.\n\nWe can create a document table dynamically by calling `saveDoc`:\n\n```javascript\ndb.saveDoc('test_attributes', {\n  productVersion: '1.0.5',\n  testEnvironment: 'production',\n  web: true,\n  accessibilityStandards: ['wcag2a', 'wcag2aa']\n}).then(attributes => {...});\n```\n\nThe `attributes` document is exactly what we passed in, with the addition of an autogenerated primary key. The key is never stored in the document body itself, but is automatically unwrapped when you persist the document.\n\nOnce the document table has been created, it's available just like any other table. You can retrieve the document again with the primary key, or query for an array of documents matching criteria:\n\n```javascript\ndb.test_attributes.findDoc(1)\n  .then(attributes => {...});\n\ndb.test_attributes.findDoc({web: true})\n  .then(matchingDocuments => {...});\n```\n\nCount documents with criteria:\n\n```javascript\ndb.test_attributes.count({web: true})\n  .then(total => {...});\n```\n\nPerform a full-text search:\n\n```javascript\ndb.test_attributes.searchDoc({\n  fields : [\"testEnvironment\", \"environment\", \"applicationStatus\"],\n  term : \"production\"\n}.then(matchingDocuments => {...});\n```\n\nPersistence functions are also adapted for document tables. You can update/insert a document with `saveDoc`; if the argument contains an `id` field, it will update the existing document in the database. If the argument contains no `id` field then it will insert a new document into the database. Either way, it returns the current state of the document.\n\nThis is not a true upsert! `saveDoc`, like `save`, determines whether to emit an `INSERT` or an `UPDATE` based on whether the data _you_ pass it contains a primary key. If you are generating primary keys manually, use `insert` instead -- if you specify a value for the primary key, it will execute an `UPDATE` whether or not the row actually exists in the database, and if it does not the result will be `null`.\n\n```javascript\nattributes.requiresAuthentication = true;\n\ndb.test_attributes.saveDoc(attributes)\n  .then(attributes => {...});\n```\n\nNote that `saveDoc` replaces the _entire_ document. To change fields without having to retrieve the document, use `modify`:\n\n```javascript\ndb.test_attributes.modify(1, {\n  requiresAuthentication: false\n}).then(attributes => {...});\n```\n\n`modify`, like `saveDoc`, returns the current version of the entire document. `modify` can also perform bulk operations with a criteria object and a changes object, just like the relational `update`:\n\n```javascript\ndb.test_attributes.modify({\n  web: true\n}, {\n  browser: 'Chrome'\n}).then(changedAttributesDocs => {...});\n```\n\nWhen changing multiple documents, `modify` returns an array containing all updated documents.\n\n### Accessing the Driver\n\nMassive is focused on convenience and simplicity, not completeness. There will always be features we don't cover; that's why there's `db.query` for arbitrary SQL. In the same vein, Massive exposes the [pg-promise] driver (as `db.pgp`) and connected [Database] instance (as `db.instance`) so client code can easily use its lower-level functions when necessary.\n\n## REPL\n\nMassive.js ships with a REPL (read-evaluate-print loop), an interactive console that lets you connect to a database and execute JavaScript code. The easiest way to run it is to install globally:\n\n```\nnpm i -g massive\n```\n\nYou can then fire up a connection and start writing JavaScript:\n\n```\nmassive -d appdb\n\ndb > db.listTables();\n[ 'tests',\n  'users' ]\n\ndb > db.tests.find({user_id: 1}).then(tests => {...});\n```\n\nIn addition to the `tables` collection, the `views` and `functions` collections are also exposed on the database object.\n\nWhen invoking functions, you may omit the `then` if you just want to see output -- Massive provides a resolver which logs the results to make it easy to query with the REPL.\n\nExit the REPL by pressing Ctrl-C twice.\n\n## Older Versions\n\nInstall Massive.js v2: `npm install massive@2`\n\nDocumentation for Massive.js 2.x is at [readthedocs](http://massive-js.readthedocs.org/en/v2/).\n\nRelease versions are tagged and available [here](https://github.com/dmfay/massive-js/releases).\n\n[pg-promise]:https://github.com/vitaly-t/pg-promise\n[Database]:http://vitaly-t.github.io/pg-promise/Database.html\n[Named Parameters]:https://github.com/vitaly-t/pg-promise#named-parameters\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dmfay/massive-js.git"
  },
  "scripts": {
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "docs": "rm -rf ./docs/api && jsdoc -d ./docs/api -c ./.jsdoc.json -r",
    "docserver": "npm run docs && cd docs && bundle exec jekyll serve",
    "lint": "eslint '.'",
    "posttest": "npm run lint",
    "postversion": "sh build/update-gh-pages.sh",
    "preversion": "sh build/apidocs.sh",
    "test": "nyc --reporter=html --reporter=text mocha"
  },
  "version": "4.7.2"
}
